/*
	ch 10. 클래스 생성자와 소멸자.
	생성자: 클래스가 인스턴스화 될 땨 필요한 초기화 작업을 위해 사용됨.
	(rvalue 참조를 사용하는 이동 생성자와 이동 대입 연산자 다룸)

	C++ 생성자-> 
		rule of three(C++11 이전): 복사 생성자, 소멸자, 복사 대입 연산자.
		rule of five(C++11 이후): 복사 생성자, 소멸자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자.
		rule of zero

		복사 생성자: 인수로 제공된 객체를 복사하여 새로운 객체를 만드는 생성자.
			단, 여기서의 복사는 객체의 주소를 복사하는 것이 아닌 객체 내부의 멤버변수들을 복사하여 새로운 객체를 생성하는 것을 의미.

		복사 대입 연산자: 이동 대입 연산자와 구별됨. 일반 대입 연산자와 같이 객체를 복사하여 이전객체의 멤버를 교체시키는 작업을 수행.

		이동 생성자: rvalue 참조를 인수로 사용하는 생성자. (rvalue 참조는 임시 저장소를 사용하는 참조로 잠깐 사용된 후 소멸되는 것을 기억.)
			새로운 객체를 생성하는 것이 아닌, 객체를 생성시키고 기존 객체의 멤버 변수를 새로운 객체의 멤버로 이동시킨다.

		이동 대입 연산자: rvalue 참조를 사용하여 대입 연산을 수행하는 연산자. 복사 대입 연산자와 달리 연산에 사용한 rvalue 참조 내의 모든 멤버 변수를 이동시킴.
		
		rule of zero는 클래스의 인스턴스를 만들어 사용할 때 사용자가 사용자 정의 생성자나 디폴트 생성자를 제외한 나머지 모든 것을 시스템에 위임하는 것.
			->튜닝의 끝은 순성 ㅆㅇㅈ.
			-> 기능을 추가하기 위해 손을 대기 시작하면 작업할 양이 증가, 안정성도 낮아질 우려.

		rule of three는 생성자와 소멸자를 만든다면 동일하게 복사 대입 연산자를 추가시켜 주어야한다는 규칙이다. 
			-> 이를 무시할 경우 프로그램이 불안한 상태가 되어 언제든지 에러가 발생할 수 있는 환경이 된다.

		일반적으로, 컴파일러는 객체나 변수를 생성하는데에는 생성자를, 이미 존재하는 객체에 대해서는 대입 연산자를 사용하려 한다.

		이번장에서 공부할 내용
		1. 생성자와 소멸자
		2. 얕은 복사와 깊은 복사
		3. rule of three
		4. rule of five
		5. 복사/이동 생략의 원칙

		1. 생성자
			i) 생성자 내부에서는 클래스의 가상함수를 호출해서는 안된다.(가상함수 -> 상속과 관련되는 함수. 하위클래스가 가상함수를 수정한다면
				에러가 발생할 수 있다.)
			ii) 가능하면 생성자 내부에서는 예외처리를 하지 않도록 한다. 만약 다른 함수에 의해서 예외가 발생한다면, 예외처리를 하지 말고
				오히려 noexcept 지정자로 에러를 내버려서 프로그램을 죽이는 것이 낫다.
				-> 객체의 생성에서 예외가 생긴다면, 처리를 한다 하더라도 완벽한 초기화는 불가능. 즉, 예외처리로 억지로 프로그램을 끌고 나가봤자
				만성적인 에러의 원인이 된다.

			그러므로, 객체가 정상적으로 생성되었는지 확인하는 멤버 함수 혹은 
						해당 클래스가 아니면서 객체의 생성을 돕는 factory 클래스 혹은
											정적 객체 생성함수를 사용하여 객체를 생성하는 것이 좋다.  -> 컴파일 시점에 생성해버림.

			*인수를 생성하기 위한 계산 작업이나 값으로 데이터 전달하기 위해 변수를 복사하는 작업은 객체를 생성하기 이전에 수행하거나,
			생성자의 인수 리스트에서 수행되어야 한다. -> 작업 중 에러가 나는 경우에 오류가 난 객체를 생성하지 않고 지나갈 수 있게 됨

			* 이미 사용한 객체는 재사용을 위한 초기화 함수를 쓰기 보단 반납하고 새로 생성하는게 낫다.

			디폴트 생성자: 생성자 이름만 있고, 별도의 인수가 없는 생성자. 개발자가 클래스 내부에 생성자를 따로
			                                                                                   만드는 경우에는 디폴트 생성자가 제공되지 않는다.
				특수한 경우
					클래스-이름()=delete;   -> 컴파일러가 자동적으로 제공하는 디폴트 생성자를 삭제.
					클래스-이름()=default;  -> 컴파일러로 하여금 디폴트 생성자를 생성해달라는 의미.

				멤버 초기화 시 함수호출연산자()를 사용할 수 있다. 
				(대표적으로, 쓰레기 값 제거를 위해 정수나 실수는 0/0.0, 문자열은 nullptr로 초기화 하는 경우)

			암시적 변환 생성자: 생성자가 여러개 정의 되어있어도 컴파일러가 자의적 해석을 하여 암시적 변환을 사용함. -> 사용자 정의 생성자가
																														암시적변환 생성자의 역할을 수행

			*복사 생략: 무분별한 복사/이동 생성자의 호출로 인한 성능 저하가 발생함을 증명하는 특정 조건들이 만족되면,
					컴파일러는 이에 따라 복사/이동 생성자의 호출을 줄이도록 작업한다. 그러므로 컴파일러는 
					대입/ 복사 생성자를 이용한 객체 생성을 하기보다는, 일반생성자를 이용하여 객체를 생성함.
							-> 일반생성자를 사용하므로, 암시적 변환 생성자(여러개가 선언되니까 어쨌든 골라야지...)를 쓰게됨
							즉, 에러가 유발 될 가능성 존재 -> 그러므로 explicit 키워드를 이용하여 자의적인 해석을 금지시킨다.
							(명시적 생성자.)

			*생성자의 상속: 클래스의 상속에 있어, 기본 클래스의 멤버는 원칙적으로 하위 클래스에게 물려주지만,
																	생성자, 소멸자, 대입 연산자는 물려주지 않는다.
				하위클래스가 상위 클래스와 구조와 이름이 당연히 다를 것이므로. 대입 연산자도 마찬가지 맥락임.

	initiallizer list클래스 템플릿: 잘모르겠어
		iterator 처럼 쓸 수있게끔? 만든다고 한다.
	변수를 초기화시키기 위해 대입 연산자 + 중괄호, 초기화하고자하는 데이터들이 리스트로 제공되며,
	변수들을 초기화하기 위해 생성자와 함께 배열을 인수로 사용하는 경우에 자동호출되어 객체를 생성한다.

	-소멸자
		객체화 된 클래스의 인스턴스가 삭제되기 전에 자동으로 실행되는 특수목적의 함수.
		대부분의 경우 클래스가 객체를 생성하면서 같이 생성한 리소스를 삭제(반환?)하기 위해 사용함. (메모리저장소/파일/네트워크/DB)

		*소멸자가 호출되는 경우:
			1. 프로그램이 종료되어서 객체를 삭제해야할 때
			2. 함수 내 지역변수와 같이 특정 지역내부에 선언된 변수가 식별자의 범위를 벗어나서 사용할 수 없게 된 경우.
			3. new 연산자를 사용하여 생성된 클래스의 인스턴스를 삭제시키기 위해 delete 연산자를 호출할 때
		*소멸자 특징(6가지)
			1. 소멸자는 인수를 가지지 않는다.
			2. 소멸자 역시 생성자와 같이 하위 클래스로 상속되지 않는다.
			3. 소멸자는 클래스에서 오직 단 하나만 존재함(생성자와는 다름.) 
			4. 하위 클래스의 소멸자가 호출되면 동시에 연관 관계의 상위 클래스의 소멸자가 자동으로 호출됨.
				->가상소멸자의 경우 예외.
			5. 소멸자는 객체가 소멸되기 직전에 자연스럽게 호출됨. 인위적인 호출도 가능하지만, 문제를 발생시킬 여지가 있다.
			6. 의미 없이 비어있는 소멸자는 만들지 말것. 객체의 삭제와 같은 태스크는 os가 작업큐에서 관리하게되므로, 가능한 한 
				태스크를 줄이기 위해서 의미없는 소멸자는 만들지 않는 것이 좋다.(문맥전환과 같은 문제를 발생)

		*가상 소멸자: 객체가 소멸될 때 호출되지 않는 소멸자
			**ㅐㅐㅣ만																																																					든 이유:
				상속 관계에서, 자식 객체가 업캐스팅 되어 있는 경우에는 객체 소멸시 상위 클래스의 소멸자만이 호출되게 된다.
				더 정확히는 아래와 같은 조건 하에 발생한다.
						1. new 연산자로 하위 클래스의 객체를 생성한다.
						2. 생성한 객체를 상위 클래스 타입의 포인터에 할당한다.(참조를 사용한다면 위의 문제가 발생하지 않음.)
						3. 이후 객체 삭제를 위해서 delete연산자를 호출한다.
				따라서, 이를 방지하기 위해 소멸자에 virtual지정자를 붙여서 가상 소멸자를 상위 클래스에 만들어주면
				virtual 키워드로 인해, 자식 클래스와 상위 클래스의 함수를 대처시켜준다.
				C언어에서 유래된 언어이기 때문에 생기는 오류(포인터)- 상속관련된 클래스에서 소멸자를 만들어야한다면 습관적으로 virtual 먹이는게 낫다.

	- 복사 생성자: 컴파일러는 클래스 내 일반 생성자의 존재여부와 상관 없이 복사 생성자를 디폴트로 제공,
			-> 형식: class명(const class명&)  //cosnt 참조가 인수인 생성자!
			그러나 만약 이 뒤에 = delete를 적는다면, 복사생성자를 삭제하므로, 복사 작업이 필요할 때마다 에러가 발생하게 된다.
			복사생성자는 다른 객체지향 언어들과 다르게 C++이 힙이 아닌 스택에 객체를 생성시키므로, 함수호출/데이터 반환시에 복사가 빈번히
			일어나게 되므로 중요하다.
			그러나 new로 객체를 생성하고, 클래스타입의 포인터를 사용하거나 참조를 이용하는 방법 만으로도, 
														위와 같이 복사가 자주 일어나는 상황에 충분히 대처할 수 있다.
		
		-얕은 복사: 소멸자 내부에서 delete연산자를 호출하여 힙메모리내의 저장소를 삭제 하는 경우 데이터가 깨지는 현상이 발생
			->원인은 컴파일러가 제공하는 복사생성자가 얕은 복사를 수행했기 때문.
				객체의 생성과 초기화에서 멤버변수를 어떻게 초기화 하느냐에 따라 얕은복사와 깊은복사로 나뉜다.
			*모든 걸 차치하고 생각.
				디폴트 복사 생성자는 객체와 객체 사이에서 멤버 변수를 복사하는 작업을 수행한다. 이 과정에서 복사 생성자는 한 객체의 각 멤버의 
				주소만을 복사하여 다른 객체의 데이터로 만들어버리는데, 이를 얕은 복사라고 한다. 즉, 이때 delete와 소멸자가 동시에 실행되는 경우
				한 저장소에 두번의 삭제, 즉 영역 침범 에러가 발생함. 
		얕은 복사: 객체에 객체를 복사할 때 주소를 이용함.
		깊은 복사: 말 그대로 모든 걸 복사하여 새 저장소에다 저장.

		위와같은 영역침범 에러는 참조룰 아용할 수 있으나, 또다시 대입 연산제 의하여 디폴트 복사 생성자를 호출할 수 있고, 이는 아까와 같은
		문제를 야기.
		그러므로, 복사생성자를 애초에 깊은 복사로 만들어 버리던가. 우리가 작업해서 만들어야할 복사생성자를 만들지 말고,
		다른 클래스에게 위임 해버리던가, 아니면 마지막으로 포인터변수를 이용해서 관리해버려야 영역침범 문제를 깔끔히 해결할 수 있다..
		가장 좋은 방법은 2(작업량은 감소, 성능은 떨어질 수 있다.) 그다음은 3(성능이 좋아질 수 있다.) 1은 복잡성이 증가하며 성능도 오르지 않음.
		기초에만 충실한 방식.

	-복사 대입 연산자:
		대입 연산자를 오버로딩하지 않고 디폴트로 제공된 대입 연산자를 사용하면 또다시 얕은 복사로 인한 영역침범 문제가 발생.
		이런 문제를 영구적으로 막기 위해 복사대입연산자 오버로딩을 만들어주어야 한다.
		형식- 클래스명& 클래스명::operator=(const 클래스명&); 
		컴파일러가 제공하는 디폴트 복사 대입연산자를 사용한다면 저 위에 = default를 쓴다.
		
	-이동 생성자와 이동 대입 연산자
		이동생성자는 rvalue참조를 사용하는 생성자. 복사생성자와는 달리 인수로 사용한 객체와 새롭게 생성한 객체의 멤버간에 
		데이터 이동이 이루어진다.
		즉, 멤버 단에서의 데이터 이동이 발생하기 때문에 얕은복사로인한 문제가 발생하지 않는다는 장점이 있다. 
		rvalue참조는 임시저장소를 사용하므로, 생성자호출->작업완료->자동삭제의 과정을 거친다.
		디폴트 이동생성자, 디폴트 이동 대입 연산자는 제공되지 않는다. 
		깊은 복사를 사용하지 않아도 상호멤버들간의 이동을 시켜서 리소스들을 가리키는 포인터를 단일 포인터로 유지시킴.

		이동 생성자를 오버로딩하는 함수는 다음과 같은 과정을 거친다.
			1. 기존 객체 내의 멤버 변수 리소스를 모두 삭제시킴
			2. 이미 존재하는 객체에 임시 객체의 멤버 변수의 데이터를 이동시킴.
			3. 임시 객체를 삭제.

			그러나 이동 대입 연산자 오버로딩시 std::swap을 이용하여 1, 2, 3을 동시에 수행함과 동시에 쓸데없이 삭제하는 시간을 줄일 수 있다.

	-복사/이동 생략의 원칙: (c++표준. 최적화를 위함)
		1. 암시적변환 생성자로 객체 생성시 하나의 객체만 생성되고 나머지는 모두 생략됨.
			ex. Complex a =1;
				Complex a = Complex(Complex(Complex(1)));
		2. 함수에서 생성한 지역변수를 반환하는 경우 복사 생성자의 호출을 생략할 수 있다.(NRVO)
		3. 무명 클래스의 인스턴스를 함수가 생성하고 반환하는경우 이동생성자의 호출이 생략된다. (RVO)
		4. ???
		fdsfs

*/
//10-4
/*
#include <iostream>

class Box {
private:
	int width;
	int length;
	int height;
public:    
	Box(int width = 0, int length = 0, int height = 0) : width(width), length(length), height(height){};  //초기화 하기.
	inline int Volume() { return width * height * length; }  //inline -> 실행빠르게...
};
class WoodBox:public Box{
public:  //상속이므로, 상위 클래스에서 제공하는 생성자를 이용하여 상위 멤버들도 초기화 해주어야 함.
	WoodBox(int w, int l, int h) : Box(w, l, h){}
};

int main(void)
{
	WoodBox* b = new WoodBox(5, 10, 3);
	std::cout << "나무상자 크기 = " << b->Volume() << std::endl;
	delete b;
}
*/
//10-6 소멸자.
/*
#include <iostream>
#include <cstring>
#include <cstdlib>

struct Account {
	char* account;
	char* name;
	int balance;
	Account(const char* id, const char* name, int bal) :
		account(new char[strlen(id) + 1]), name(new char[strlen(name) + 1]), balance(bal) {
		strcpy(this->account, id);
		strcpy(this->name, name);
		std::cout << "Account 생성자가 호출되었습니다." << std::endl;
	}

	//구조체 내의 소멸자를 만들면 객체 소멸시 자동으로 호출됨.
	~Account() {
		//더이상 사용하지 않는 객체이므로 힙 메모리를 반환함.
		std::cout << "Account소멸자 호출" << std::endl;
		delete[] account;
		delete[] name;
	}

	void Print() {
		printf("계좌: %s, 소유자:%s", account, name);
		printf(", 잔액: %i \n", balance);
	}
	void Deposit(int money) {
		balance += money;

	}
	
	void withdraw(int money) {
		balance -= money;
	}
};
int main()
{
	//구조체는 new와 함께 사용될 때 힙영역의 공간을 할당받는다.
	Account* hong = new Account("111", "홍길동", 60000);

	if (NULL == hong)return -1;
	
	{
		Account kim("222", "김홍도", 0);
		hong->withdraw(2000);
		kim.Deposit(2000);
		hong->Print();
		kim.Print();
	}

	delete hong;
}
*/
//10-10
//string타입으로 변경하여 얕은복사를 해도 문제 없도록 만들기
//문제가 해결되는 이유. 
//멤버가 애초에 string이니, 객체 생성은 아니지만, 그 내부에서 문자열을 생성, 관리하는 작업은 string클래스가 해주기 때문에,
//display와 같은 함수로 인해 얕은 복사가 된 후 소멸하더라도, 
//이때의 소멸되는 객체의 string멤버는 따로 관리가 되기 때문에 (지들끼리 깊은 복사를 하나보지?) 문제가 생기지 않는 모양
#include <string>
class MyString {
	MyString(const char* n);
	const char* GetString() const;
	int GetLength() const;
private:
	std::string data;  //애초에 데이터를 표준 string으로 사용한다.


};
MyString::MyString(const char* n) :data(n) {
	//일반적인 생성자
	printf("Mystring::Mystring(const char *%s)\n", n);
}
MyString::~MyString() {
	//마찬가지로 일반적인 소멸자. Rule of zero로 생략해도 됨.
	printf("Mystring::Mystring('%s') 소멸자 호출\n", data.data());
}

//객체에 저장된 문자열을 반환하는 멤버함수
const char* MyString::GetString() const {
	return data.data();
}

int MyString::GetLength() const {
	return data.length(); //string 클래스의 length함수 사용.
}
int main()
{
	MyString s1("HelloWorld"), s2 = "복사생성자";
}
