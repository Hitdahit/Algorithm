//ch8 Reference
//ch9 type changing&lambda
/*
	ch8 && ch9


	저장소: 변수, 포인터, 참조!
	변수: 선언과 동시에 스택 메모리공간의 저장공간을 받음. (데이터의 입출력을 담당)
	포인터: 다른 저장소를 가리키는 메모리주소를 스택 메모리 공간을 받아 그곳에 보관한다.
	참조: 일반변수의 저장소를 공유하기 위해 만든 실제 변수가 아닌 컴파일러가 인지하는 가상변수.
			->즉, 다른 저장소를 가리키는 용도로 사용하는 가상변수.(별도의 저장공간이 존재하지 않음.)

	&로 참조 타입임을 표시한다. 컴파일러는 &를 변수를 참조하기 위한 목적으로 사용.

	참조는 포인터를 없애기 위해서 추가된 개념.
	포인터는 메모리 주소를 직접 가르키기 때문에 빠르다는 장점이 있지만, 
	동시에 해커들에게 공격당하는 취약점이 될 수 있다. 

	객체지향의 캡슐화 측면에서, 포인터는 좋지 않은 방식.
	그러므로, 참조라는 개념을 만듬.

	참조 v.s. 포인터 차이점.
	1. 포인터에는 NULL값이 있지만, 참조자는 없다. 
		참조자는 선언시 바로 초기화 해주어야 한다.
	2. 참조자는 변수를, 포인터는 주소를 대입받는다.
	3. 참조자는 한 번 객체가 지정되면 바꿀 수 없지만, 포인터는 가능하다.
	4. 참조자는 가상 포인터와 가상테이블을 지원함.

	*참고: 객체지향에서, 기본 타입의 변수는 선언과 동시에 스택 메모리에 저장소를 갖는다. 그러나
		객체는 힙 메모리 공간에 저장소를 갖는다. 그러므로, 전역변수처럼 사용이 가능하다.

	C++ 11부터 참조는 lvalue, rvalue로 나뉘게 되었다. 
	-대입: 어떠한 식이 의미 있게 하기 위해서, 변수에 작업 결과를 입력시키는 작업.
	
	lvalue: 대입연산자의 왼쪽에 있는 변수. /
	저장소의 위치를 가리키는 포인터를 반환하는 함수. 변수의 데이터타입을 바꾸는 변환 연산자

	rvalue: 대입연산자의 오른쪽에 있는 변수.
	데이터의 이동이나 복사가 존재함. 메모리의 주소를 알 수 없다(&를 쓸 수 없다.)
	아이덴티티가 없는 rvalue는 lvalue로 쓸 수 없다.

	prvalue: 순수하게 rvalue로만 쓸 수 있는 것. 아이덴티티를 가지지 않으며, 데이터의 이동이나 복사만 가능하다.

	xvalue: 삭제 예정값으로, rvalue와 같이 임시저장소임에도 아이덴티티의 속성을 부여할 수 있다면, 새로운 형태의 rvalue참조를 만들 수 있다

	*업캐스트와 다운캐스트 수행시 반드시 참조를 사용해야함! -> 일반 변수 사용시 실제 저장소를 가리키게 되므로 잘못된 결과를 얻는다.
	
	lvalue참조를 이용하여 함수 호출시, 객체의 복사 없이 함수를 이용할 수 있으므로 프로그램의 수행속도를 높일 수 있다.

	-참조 사용시 주의
	1. 참조는 암시적 상수와 같이 선언과 동시에 참조할 객체를 넣어주어야 한다.
		만약 참조가 클래스의 멤버변수에 이루어진다면 const 멤버처럼 생성자로 객체 생성과 동시에 초기화를 해주어야 한다.

	2. 참조는 한번 생성된 이후에 다른 객체/변수로 변경되지 않음. 만약 다른 객체/변수가 대입 되더라도 값이 변할 뿐, 참조가 변하지 않음

	3. 참조는 원칙적으로 변수가 아니므로, 참조 초기화시 상수를 사용할 수 없다. 상수를 사용하기 위해선 const키워드로 명시적 상수로 만들고 써야함.

	4. 참조는 NULL을 허용하지 않는다. 참조에는 주소가 들어갈 수 없다.

	5. typedef using auto 모두 사용가능함.

	6. 참조는 배열내의 요소와 공간을 공유할 수 있지만, 포인터처럼 배열 전체는 가리킬 수 없다.
	
	rvalue 참조: 객체 지향의 원칙 보다는 프로그램의 성능향상, 개발 생산성에 초점.
	-> 이동생성자, 이동 대입 연산자의 인수로 사용.
	-> 완벽한 포워딩 == 함수오버로딩의 갯수를 줄여줌. (템플릿과 섞으면 일반화가 가능.)

	???유니버셜 참조?

	타입 변환과 람다.
	
	암시적 변환: 컴파일러가 알아서 타입을 변환.
	명시적 변환: 컴파일러가 개발자의 의도를 파악하기 힘든 경우. 혹은 컴파일러가 함부로 최적화 하지 못하는 경우.

	데이터의 크기 변환: 오버플로 혹은 언더플로의 위험은 프로그래머가 예방해야. (자원이 불충분한 환경이라면 일일이 따져야.)

	타입변환 연산자: C에서 제공하는 명시적 변환은 괄호를 사용하는 연산 뿐.
		C의 명시적 타입 변환이 나쁜 이유.
		1. 데이터가 원하는 대상 타입으로 변환이 가능한지 컴파일러가 확인해 주지 않음. ->개발자에게 이책임을 떠맡김.
		2. C가 보는 타입변환: 형식변환 작업. C++이 보는 타입변환: 연산 작업.

		만약 사용하는 변환 대상이 C의 기본타입이라면 상관 x
		그러나 객체지향의 클래스나 구조체와 같은 묶음 타입 내지는 C에서 제공하지 않는 문법의 타입이라면, 타입변환 연산자를 사용할 것!
		종류:
		static_cast
		dynamic_cast
		const_cast
		reinterpret_cast


		*참고: 각 언어에서 static의 차이.
			C: 정적변수(항상 전역변수 x)  외부파일 접근x(extern 키워드로도 접근불가.)
			C++: C와 비슷함. 접근지정자. 
			JAVA: 가장 중요한 건 컴파일 시점에 이미 메모리에 올라가 있다는 점.
			non-static 멤버 VS static 멤버
				non-static 멤버
				
				공간적 특성: 멤버는 객체마다 별도로 존재한다.
				인스턴스 멤버 라고 부른다.
				시간적 특성: 객체 생성 시에 멤버가 생성된다.
				객체가 생길 때 멤버도 생성된다.
				객체 생성 후 멤버 사용이 가능하다.
				객체가 사라지면 멤버도 사라진다.
				공유의 특성: 공유되지 않는다.
				멤버는 객체 내에 각각의 공간을 유지한다.
				
				static 멤버
				
				공간적 특성: 멤버는 클래스당 하나가 생성된다.
				멤버는 객체 내부가 아닌 별도의 공간에 생성된다.
				클래스 멤버 라고 부른다.
				시간적 특성: 클래스 로딩 시에 멤버가 생성된다.
				객체가 생기기 전에 이미 생성된다.
				객체가 생기기 전에도 사용이 가능하다. (즉, 객체를 생성하지 않고도 사용할 수 있다.)
				객체가 사라져도 멤버는 사라지지 않는다.
				멤버는 프로그램이 종료될 때 사라진다.
				공유의 특성: 동일한 클래스의 모든 객체들에 의해 공유됨
	
	람다: 일종의 함수인 동시에 식.

	-static_cast연산자.
	static_cast<new_type> (expression);    //expression의 결과 값의 형식을 new_type으로 변환.
*/


//8-4
//pass by reference. 참조에 의한 전달.
/*
#include <iostream>

void swapref(int& a, int& b)   //파라미터들에 const를 씌워 두면, 값의 변경 조차 막을 수 있다.
{
	int c(a);      //오로지 값의 변경만을 허용하며, 이로 인해 더 유연하지만 동시에 보안적으로도 안전한 코드가 된다.
	a = b;
	b = c;
}
int main()
{
	//본래 C, C++ 입출력은 혼용이 가능. 동기화가 되어 있기 때문.
	//C표준 stream과 C++ 표준 stream의 동기화를 끊는 방법.
	//ios::sync_with_stdio(false);
	//이 방법은 C++ stream에게만 버퍼를 제공. 즉 버퍼의 수가 줄어들어 실행속도가 향상됨.
	//하지만 동기화가 끊어지면 thread 간에 자원 lock을 걸지 못하기 때문에 충돌이 발생.

	int x = 10, y = 20;
	swapref(x, y);

	std::cout << "x: " << x << "y: " << y << "\n";

	return 0;
}
*/
//9-1
//static_cast의 활용도: int* 를 long*에 담는 방법.
/*
#include <iostream>
#include <vector>
int main()
{
	int n = 100;
	void* nv = &n;  //int 변수의 주소 저장.

	long* n01 = static_cast<long*>(nv);  //long* 타입의 포인터로 캐스트.
	int* n02 = static_cast<int*>(&n);   
	int* n03 = &n;          //이럴거면 n02를 쓸 이유가..?

	std::cout << "n = " << n
		<< ", *n01 = " << *n01
		<< ", *n02 = " << *n02 
		<<", *n03 = " << *n03 << "\n";

	std::vector <long> e = { 1, 23, 10 };   //vector 초기화 방법.  e{1, 23, 10}; e.push_back()... 등
	void* voidp = &e;    //벡터 배열의 첫요소의 주소형식 == vector<int>*

	std::vector<int>* vec = static_cast<std::vector <int>*>(voidp);   //컨테이너가 관리하는 요소의 타입을 long에서 int로 변환

	std::vector<int> vr = *vec;
	for (int a : vr)   //범위 기반 for문. auto추천. 
		std::cout << a << ' ';  

	std::cout << std::endl;   
}
*/
//9-3
//클래스 형 변환을 하는 것은 변수의 주소에 영향을 주지 않는다.
#include <iostream>
class Base {
public:
	virtual void dummy() {  //순수가상함수? 복습.
		std::cout << "Base dummy() 호출\n";
	}
};
//상속하기. 모든 멤버를 public으로 였던가?
class Derived :public Base {
public:
	void SetNumber(int i) {
		number = i;
	}
	int number;   //public임. 아마도.
};

int main()
{
	Derived d;    //자식
	Base& br = d;  //업캐스팅. SetNumber, number에 접근이 불가능.

	//Derived& another_d = (Derived&)br;  //업캐스팅은 명시적변환도 허용.

	Derived& another_d = static_cast<Derived&>(br);    
	printf("d = %p, br = %p, another_d = %p\n", &d, &br, &another_d);   //d, another_d의 주소가 같다. 

	Derived a[10];
	Base* dp = static_cast<Base*>(a);
	printf("a = %p, dp = %p\n", a, dp);



}
